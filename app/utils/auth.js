const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const CustomError = require('./error');

const authMiddleware = async (req, res, next) => {
  const { user } = req.session;
  try {
    if (!user || !user.token) {
      throw new CustomError('Not Authorized', 401, 0);
    } else if (user && user.token) {
      await new Promise((resolve, reject) => {
        jwt.verify(user.token, '1234', (err) => {
          if (err) {
            return req.session.destroy((error) => {
              if (error) {
                return next(error);
              }
              res.clearCookie('sessionId');
              reject(new CustomError('Not Authorized', 401, 1));
            });
          }
          resolve();
        });
      });
    }
    return next();
  } catch (error) {
    return next(error);
  }
};


const hashConfig = {
  hashBytes: 32,
  saltBytes: 16,
  digest: 'sha512',
  iterations: 100000,
};

/**
 * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Returns a self-contained buffer which can be arbitrarily encoded for storage
 * that contains all the data needed to verify a password.
 *
 * @param {!String} password
 * @param {!function(?Error, ?Buffer=)} callback
 */
const hashPassword = (password, callback) => {
  // generate a salt for pbkdf2
  crypto.randomBytes(hashConfig.saltBytes, (err, salt) => {
    if (err) {
      return callback(err);
    }

    return crypto.pbkdf2(password, salt, hashConfig.iterations, hashConfig.hashBytes, hashConfig.digest, (error, hash) => {
      if (error) {
        return callback(error);
      }

      const combined = Buffer.alloc(hash.length + salt.length + 8);

      // include the size of the salt so that we can, during verification,
      // figure out how much of the hash is salt
      combined.writeUInt32BE(salt.length, 0, true);
      combined.writeUInt32BE(hashConfig.iterations, 4, true);

      salt.copy(combined, 8);
      hash.copy(combined, salt.length + 8);
      callback(null, combined);
      return false;
    });
  });
};

/*
  Accepts a hash and salt generated by hashPassword
 */
const verifyPassword = (password = '', combined, callback) => {
  try {
    const buffer = combined;
    // extract the salt and hash from the combined buffer
    const saltBytes = buffer.readUInt32BE(0);
    const hashBytes = buffer.length - saltBytes - 8;
    const iterations = buffer.readUInt32BE(4);
    const salt = buffer.slice(8, saltBytes + 8);
    const hash = buffer.toString('binary', saltBytes + 8);
    const { digest } = hashConfig;

    // verify the salt and hash against the password
    crypto.pbkdf2(password, salt, iterations, hashBytes, digest, (err, verify) => {
      if (err) {
        return callback(err, false);
      }

      callback(null, verify.toString('binary') === hash);
      return false;
    });
  } catch (error) {
    callback(error, false);
  }
};

module.exports = {
  hashPassword,
  verifyPassword,
  authMiddleware,
};
